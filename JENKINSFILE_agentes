pipeline {
    agent any
    stages {
        stage('Checkout') {
            steps {
                checkout scm: [
                    $class: 'GitSCM',
                    branches: [[name: '*/master']],
                    doGenerateSubmoduleConfigurations: false,
                    extensions: [
                        [$class: 'CloneOption', noCheckout: true]  // Evita el checkout automàtic
                    ]
                ]
            }
        }
        stage('GetCode') {
            agent { label 'Agent1' }
            steps {
                echo "Datos de ejecución en el stage ${env.STAGE_NAME}:"
                echo "${WORKSPACE}"
                sh '''
                    whoami
                    hostname
                '''
                echo "Limpio el workspace:"
                cleanWs()
                echo "Bajo el código del depósito de GitHub:"
                git credentialsId: 'GitHubROpwd', url: 'https://github.com/unir-dbenach/unir-p1-dbenach.git'
            }
        }
        stage('Build') {
            agent { label 'Agent1' }
            steps {
                echo "Datos de ejecución en el stage ${env.STAGE_NAME}:"
                echo "${WORKSPACE}"
                sh '''
                    whoami
                    hostname
                '''
                echo "En este stage se prepara el codigo para ser desplegado. En nuestro caso, solo es necesario bajarlo de GitHub. Veamos como queda distribuido en el WorkSpace:"
                sh "pwd"
                sh "ls -l"
                echo "Ejecuto los stash para poder pasar los ficheros necesarios a los agentes:"    
                stash includes: 'app/**', name: 'code'                // Contiene el código de la aplicación
                stash includes: 'test/rest/**', name: 'testRest'      // Contiene el fichero de pruebas para rest.
                stash includes: 'test/wiremock/**', name: 'wmMapping' // Contiene los mappings de WireMock
                stash includes: 'pytest.ini', name: 'pytestIni'       // Contiene el pytest.ini, necesario para el test de rest al definir markers 
            }
        }
        stage ('Testing') {    // Ejecutamos en paralelo los stages que levantan la aplicación y los tests uni y rest.
            parallel {
                stage ('StartApp') {
                    agent { label 'Agent3' }
                    steps {
                        echo "Datos de ejecución en el stage ${env.STAGE_NAME}:"
                        echo "${WORKSPACE}"
                        sh '''
                            whoami
                            hostname
                        '''
                        echo "Limpiamos el workspace:"
                        cleanWs()
                        echo "Recuperamos los ficheros de código necesarios:"
                        unstash 'code'
                        unstash 'wmMapping'
                        echo "Levantamos los contenendores de Flask y WireMock:"
                        sh """
                            docker run -d --name wiremock-${env.BUILD_ID} --rm -p 9090:8080 -v ${WORKSPACE}/test/wiremock:/home/wiremock wiremock/wiremock:latest
                            docker run -d --name flask-${env.BUILD_ID} --rm -p 5000:5000  -e FLASK_APP=app/api.py -e PYTHONPATH=/app -v ${WORKSPACE}:/app flask
                        """
                    }
                }
                stage ('Unit') {
                    agent { label 'Agent1' }
                    steps {
                        echo "Datos de ejecución en el stage ${env.STAGE_NAME}:"
                        echo "${WORKSPACE}"
                        sh '''
                            whoami
                            hostname
                        '''
                        echo "Ejecutamos el test UNIT:"
                        catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE') {
                            sh '''
                                export PYTHONPATH=${WORKSPACE}
                                pytest --junit-xml=result-unit.xml test/unit
                            '''
                        }
                    }
                }
                stage ('Rest') {
                    agent { label 'Agent2' }
                    steps {
                        echo "Datos de ejecución en el stage ${env.STAGE_NAME}:"
                        echo "${WORKSPACE}"
                        sh '''
                            whoami
                            hostname
                        '''
                        echo "Limpiamos el workspace"
                        cleanWs()
                        echo "Recuperamos los ficheros de código necesarios:"
                        unstash 'testRest'
                        unstash 'pytestIni'
                        echo "Verificamos si la aplicación ya está disponible para realizar las pruebas:"
                        catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE') {
                            sh '''
                                for i in $(seq 0 1 10); do
                                    if nc -z 192.168.71.10 9090; then
                                        echo "Puerto 9090 disponible. Comprobamos el puerto 5000."
                                        if nc -z 192.168.71.10 5000; then
                                            echo "Puerto 5000 también disponible. Lanzamos el test." 
                                            export PYTHONPATH=${WORKSPACE}
                                            pytest --junit-xml=result-rest.xml test/rest
                                            exit 0
                                        else
                                            echo "El puerto 5000 aun no está levantado. Espero un segundo ($i)."
                                        fi
                                    else
                                        echo "El puerto 9090 todavia no se ha levantado. Espero un segundo. ($i)"
                                    fi
                                    sleep 1
                                done
                                echo "La aplicación no se ha levantado en el tiempo esperado. Abortamos el test."
                                exit 1
                            '''    
                            echo "Guardamos el fichero de resultado:"
                            stash includes: 'result-rest.xml', name: 'resultRest'
                        }
                    }
                }
            }
        }
        stage ('Results') {
            agent { label 'Agent1' }
            steps {
                echo "Datos de ejecución en el stage ${env.STAGE_NAME}:"
                echo "${WORKSPACE}"
                sh '''
                    whoami
                    hostname
                '''
                echo "Traemos el fichero de pruebas de rest ya que se ha ejecutado en el agente2:"
                unstash 'resultRest'
                echo "Ejecutamos junit para procesar los dos ficheros generados (el de unit ya existe en este nodo)."
                junit 'result*.xml'
            }
        }
    }
    post {
        always {
            script {
                echo "Hemos definido un post que siempre se ejecuta para limpiar la ejecución de la pipeline:"
                node('Agent1') {
                    echo "Limpio el workspace del agente1"
                    deleteDir()
                }
                node('Agent2') {
                    echo "Limpio el workspace del agente2"
                    deleteDir()
                }
                node('Agent3') {
                    echo "Paro los contenedores instanciados en el agente3:"
                    sh """
                        docker stop wiremock-${env.BUILD_ID}
                        docker stop flask-${env.BUILD_ID}
                    """
                    echo "Limpio el workspace del agente3"
                    deleteDir()
                }
            }
        }
    }
}

